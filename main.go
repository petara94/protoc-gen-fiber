package main

import (
	"github.com/envoyproxy/protoc-gen-validate/validate"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"slices"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate || len(f.Services) == 0 {
				continue
			}

			g := plugin.NewGeneratedFile(f.GeneratedFilenamePrefix+"_fiber.gw.go", f.GoImportPath)
			g.P("// Code generated by protoc-gen-fiber. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)

			g.P("import (")
			g.P(`"context"`)
			g.P(``)
			g.P(`	"git.muzpan.com/proto/lib/utils"`)
			g.P(`	"github.com/gofiber/fiber/v2"`)
			g.P(`	"google.golang.org/grpc"`)
			g.P(`	"google.golang.org/grpc/metadata"`)

			// add marshaller import if marshaller needed
			if slices.ContainsFunc(f.Services, func(service *protogen.Service) bool {
				return slices.ContainsFunc(service.Methods, func(method *protogen.Method) bool {
					return method.Input.GoIdent.GoName != "Empty"
				})
			}) {
				g.P(`	"google.golang.org/protobuf/encoding/protojson"`)
			}

			g.P(")")

			for _, service := range f.Services {
				g.P("func Register", service.GoName, "FiberRoutes(app *fiber.App, server ", service.GoName, "Server, interceptor grpc.UnaryServerInterceptor) {")
				for i, method := range service.Methods {
					opts := method.Desc.Options().(*descriptorpb.MethodOptions)

					methodType, httpPath := grpcOptionToMethodAndPathString(opts)
					if httpPath == "/" {
						httpPath += method.GoName
					}

					g.P(`	app.`+methodType+`("`, httpPath, `", func(c *fiber.Ctx) error {`)
					g.P("		ctx, cancel := context.WithCancel(c.Context())")
					g.P("		defer cancel()\n")

					g.P("		md := metadata.New(nil)")
					g.P("		c.Request().Header.VisitAll(func(key, value []byte) {")
					g.P("		md.Append(string(key), string(value))")
					g.P("		})\n")

					g.P("		ctx = metadata.NewIncomingContext(ctx, md)\n")

					g.P("		var req ", method.Input.GoIdent)

					// use marshaller if we need
					if method.Input.GoIdent.GoName != "Empty" {
						g.P("		if err := protojson.Unmarshal(c.Body(), &req); err != nil { return err }\n")

						hasValidation := false
						for _, field := range method.Input.Fields {
							if proto.HasExtension(field.Desc.Options(), validate.E_Rules) {
								hasValidation = true
								break
							}
						}

						if hasValidation {
							g.P("		if err := req.Validate(); err != nil {")
							g.P("			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": err.Error()})")
							g.P("		}\n")
						}
					}

					g.P("	handler := func(ctx context.Context, r any) (any, error) {")
					g.P("		return server.", method.GoName, "(ctx, r.(*", method.Input.GoIdent, "))")
					g.P("	}")
					g.P()
					g.P("	info := &grpc.UnaryServerInfo{")
					g.P("		Server: server,")
					g.P(`		FullMethod: "/`, string(service.Desc.FullName()), "/", string(method.Desc.Name()), `",`)
					g.P("	}")

					g.P("	resp, err := interceptor(ctx, &req, info, handler)")
					g.P("	if err != nil { return utils.HandleGRPCStatusError(c, err) }\n")

					g.P("	return c.JSON(resp)")

					if i == len(service.Methods)-1 {
						g.P("	})")
					} else {
						g.P("	})\n")
					}
				}
				g.P("}\n")
			}
		}

		return nil
	})
}

// grpcOptionToMethodAndPathString узнает метод из google.api.http
func grpcOptionToMethodAndPathString(opts *descriptorpb.MethodOptions) (string, string) {
	ext := proto.GetExtension(opts, annotations.E_Http)
	var methodType, path string

	if httpRule, ok := ext.(*annotations.HttpRule); ok {

		switch pattern := httpRule.Pattern.(type) {
		case *annotations.HttpRule_Get:
			methodType = "Get"
			path = pattern.Get
		case *annotations.HttpRule_Post:
			methodType = "Post"
			path = pattern.Post
		case *annotations.HttpRule_Put:
			methodType = "Put"
			path = pattern.Put
		case *annotations.HttpRule_Patch:
			methodType = "Patch"
			path = pattern.Patch
		case *annotations.HttpRule_Delete:
			methodType = "Delete"
			path = pattern.Delete
		default:
			// fallback
			methodType = "Post"
			path = "/"
		}
	}
	return methodType, path
}
