package main

import (
	"github.com/envoyproxy/protoc-gen-validate/validate"
	annotations "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}
			g := plugin.NewGeneratedFile(f.GeneratedFilenamePrefix+"_fiber.gw.go", f.GoImportPath)
			g.P("// Code generated by protoc-gen-fiber. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)

			g.P("import (")
			g.P(`"context"`)
			g.P(``)
			g.P(`"github.com/gofiber/fiber/v2"`)
			g.P(`"google.golang.org/grpc/metadata"`)
			g.P(")")

			for _, service := range f.Services {
				g.P("func Register", service.GoName, "FiberRoutes(app *fiber.App, client ", service.GoName, "Server) {")
				for i, method := range service.Methods {
					opts := method.Desc.Options().(*descriptorpb.MethodOptions)

					methodType, httpPath := grpcOptionToMethodAndPathString(opts)
					if httpPath == "/" {
						httpPath += method.GoName
					}

					g.P(`  app.`+methodType+`("`, httpPath, `", func(c *fiber.Ctx) error {`)
					g.P("      ctx, cancel := context.WithCancel(c.Context())")
					g.P("      defer cancel()\n")

					g.P("      md := metadata.New(nil)")
					g.P("      c.Request().Header.VisitAll(func(key, value []byte) {")
					g.P("      md.Append(string(key), string(value))")
					g.P("      })\n")

					g.P("      ctx = metadata.NewOutgoingContext(ctx, md)\n")

					g.P("      var req ", method.Input.GoIdent)
					if method.Input.GoIdent.GoName != "Empty" {
						g.P("      if err := c.BodyParser(&req); err != nil { return err }\n")

						hasValidation := false
						for _, field := range method.Input.Fields {
							if proto.HasExtension(field.Desc.Options(), validate.E_Rules) {
								hasValidation = true
								break
							}
						}

						if hasValidation {
							g.P("      if err := req.Validate(); err != nil {")
							g.P("            return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": err.Error()})")
							g.P("      }\n")
						}
					}

					g.P("      resp, err := client.", method.GoName, "(ctx, &req)")
					g.P("      if err != nil { return err }\n")

					g.P("      return c.JSON(resp)")

					if i == len(service.Methods)-1 {
						g.P("  })")
					} else {
						g.P("  })\n")
					}
				}
				g.P("}\n")
			}
		}

		return nil
	})
}

// grpcOptionToMethodAndPathString узнает метод из google.api.http
func grpcOptionToMethodAndPathString(opts *descriptorpb.MethodOptions) (string, string) {
	ext := proto.GetExtension(opts, annotations.E_Http)
	var methodType, path string

	if httpRule, ok := ext.(*annotations.HttpRule); ok {

		switch pattern := httpRule.Pattern.(type) {
		case *annotations.HttpRule_Get:
			methodType = "Get"
			path = pattern.Get
		case *annotations.HttpRule_Post:
			methodType = "Post"
			path = pattern.Post
		case *annotations.HttpRule_Put:
			methodType = "Put"
			path = pattern.Put
		case *annotations.HttpRule_Patch:
			methodType = "Patch"
			path = pattern.Patch
		case *annotations.HttpRule_Delete:
			methodType = "Delete"
			path = pattern.Delete
		default:
			// fallback
			methodType = "Post"
			path = "/"
		}
	}
	return methodType, path
}
