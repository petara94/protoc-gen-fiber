package main

import (
	"github.com/envoyproxy/protoc-gen-validate/validate"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

func generateFile(plugin *protogen.Plugin) error {
	flagInit()

	for _, f := range plugin.Files {
		if !f.Generate || len(f.Services) == 0 {
			continue
		}

		g := plugin.NewGeneratedFile(f.GeneratedFilenamePrefix+"_fiber.gw.go", f.GoImportPath)
		g.P("// Code generated by protoc-gen-fiber. DO NOT EDIT.")
		g.P("package ", f.GoPackageName)

		generateImports(g, f)

		for _, service := range f.Services {
			g.P("func Register", service.GoName, "FiberRoutes(app *", fiberImport.Ident("App"), ", server ", service.GoName, "Server, interceptor grpc.UnaryServerInterceptor) {")
			for _, method := range service.Methods {
				generateFiberMethodRote(g, method)
			}
			g.P("}")
			g.P()

			for _, method := range service.Methods {
				generateMethods(g, method)
			}
		}
	}

	return nil
}

func generateImports(g *protogen.GeneratedFile, f *protogen.File) {
	g.Import(contextImport)
	g.Import(fiberImport)
	g.Import(grpcImport)
	g.Import(grpcMetadataImport)
	g.Import(errorHandlersImport)
}

func generateMethods(g *protogen.GeneratedFile, method *protogen.Method) {
	g.P("func ", generateRouteMethodName(method), `(c *`, fiberImport.Ident("Ctx"), `) error {`)

	g.P("		ctx, cancel := ", contextImport.Ident("WithCancel"), "(c.Context())")
	g.P("		defer cancel()\n")

	g.P("		md := ", grpcMetadataImport.Ident("New"), "(nil)")
	g.P("		c.Request().Header.VisitAll(func(key, value []byte) {")
	g.P("		md.Append(string(key), string(value))")
	g.P("		})\n")

	g.P("		ctx = metadata.NewIncomingContext(ctx, md)\n")

	g.P("		var req ", method.Input.GoIdent)

	// use marshaller if we need
	if method.Input.GoIdent.GoName != "Empty" {
		g.P("		if err := ", jsonUnmarshalImport.Ident("Unmarshal"), "(c.Body(), &req); err != nil {")
		g.P("			return ", errorHandlersImport.Ident(*flagUnmarshalErrorHandleFunc), "(c, err)")
		g.P("		}")
		g.P()

		hasValidation := false
		for _, field := range method.Input.Fields {
			if proto.HasExtension(field.Desc.Options(), validate.E_Rules) {
				hasValidation = true
				break
			}
		}

		if hasValidation {
			g.P("		if err := req.Validate(); err != nil {")
			g.P("			return ", errorHandlersImport.Ident(*flagValidationErrorHandleFunc), "(c, err)")
			g.P("		}")
			g.P()
		}
	}

	g.P("	handler := func(ctx context.Context, r any) (any, error) {")
	g.P("		return server.", method.GoName, "(ctx, r.(*", method.Input.GoIdent, "))")
	g.P("	}")
	g.P()
	g.P("	info := &", grpcImport.Ident("UnaryServerInfo"), "{")
	g.P("		Server: server,")
	g.P(`		FullMethod: "/`, string(method.Parent.Desc.FullName()), "/", string(method.Desc.Name()), `",`)
	g.P("	}")

	g.P("	resp, err := interceptor(ctx, &req, info, handler)")
	g.P("	if err != nil { return utils.HandleGRPCStatusError(c, err) }\n")

	g.P("	return c.JSON(resp)")

	g.P("	}")

}

// grpcOptionToMethodAndPathString узнает метод из google.api.http
func grpcOptionToMethodAndPathString(opts *descriptorpb.MethodOptions) (string, string) {
	ext := proto.GetExtension(opts, annotations.E_Http)
	var methodType, path string

	if httpRule, ok := ext.(*annotations.HttpRule); ok {

		switch pattern := httpRule.Pattern.(type) {
		case *annotations.HttpRule_Get:
			methodType = "Get"
			path = pattern.Get
		case *annotations.HttpRule_Post:
			methodType = "Post"
			path = pattern.Post
		case *annotations.HttpRule_Put:
			methodType = "Put"
			path = pattern.Put
		case *annotations.HttpRule_Patch:
			methodType = "Patch"
			path = pattern.Patch
		case *annotations.HttpRule_Delete:
			methodType = "Delete"
			path = pattern.Delete
		default:
			// fallback
			methodType = "Post"
			path = "/"
		}
	}
	return methodType, path
}
